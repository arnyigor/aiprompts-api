Конечно. Вы предоставили очень подробный и дальновидный план. Интеграция полноценной OAuth-аутентификации — это следующий, самый важный шаг в развитии вашего проекта. Он превращает его из анонимного инструмента в платформу для контрибьюторов.

Я возьму ваше текущее ТЗ и полностью переработаю его, чтобы оно отражало эту новую, более зрелую и безопасную архитектуру.

### АКТВИРОВАН ПРОФІЛЬ 2: Исследователь-аналитик

---

### **Техническое Задание: AIPrompts Hub — Архитектура v3.0**

**Версия:** 3.0
**Дата:** 05.08.2025
**Автор:** AI-Аналитик (на основе утвержденной архитектуры)

---

#### **1. Введение**

**1.1. Цель документа**

Настоящее ТЗ описывает требования к внедрению **системы аутентификации пользователей через GitHub OAuth** и расширению гибридной архитектуры бэкенд-сервиса "AIPrompts Hub". Документ детализирует новые API-маршруты для авторизации, обновляет требования к существующим эндпоинтам и определяет новые стандарты безопасности.

**1.2. Контекст и Архитектура**

Проект переходит на **идентификационную модель участия**. Все операции, изменяющие контент (создание/редактирование промптов), теперь будут выполняться от имени аутентифицированного пользователя, что повышает прозрачность и безопасность.

Архитектура остается **гибридной**, но обогащается новым слоем:
*   **Слой Аутентификации (NextAuth.js):** Централизованно управляет сессиями пользователей и доступом к защищенным API.
*   **Источник правды для контента (Git):** Остается без изменений, но операции теперь используют персональные токены пользователей.
*   **Источник правды для динамических данных (Vercel Storage):** Остается без изменений.

---

#### **2. Технологический Стек и Окружение**

*   **Платформа:** Vercel
*   **Среда выполнения:** Node.js
*   **Хранилища данных:**
    *   Vercel KV (Redis)
    *   Vercel Postgres
*   **Ключевые зависимости (NPM):**
    *   `@octokit/rest`: Взаимодействие с GitHub REST API.
    *   `zod`: Валидация схем данных.
    *   `@vercel/kv`, `@vercel/postgres`: Работа с хранилищами.
    *   **`next-auth`**: Ключевая библиотека для реализации GitHub OAuth.
*   **Аутентификация:** GitHub OAuth flow, управляемый `NextAuth.js`. **Персональные токены пользователей**, полученные через OAuth, используются для Git-операций вместо единого серверного PAT.

---

#### **3. Функциональные Требования: API Эндпоинты**

##### **3.1. Управление Промптами (Git-based)**

*   **`POST /api/create-prompt-issue` (Защищенный)**
    *   **Назначение:** Принимает данные нового или обновленного промпта от **аутентифицированного пользователя**.
    *   **Логика:**
        1.  Проверяет наличие активной сессии пользователя.
        2.  Валидирует данные по схеме Zod.
        3.  Управляет датами `created_at` / `updated_at` на сервере.
        4.  **Автоматически обогащает** данные информацией об авторе из сессии (GitHub username, id, email).
        5.  Используя **токен пользователя из сессии**, выполняет атомарную Git-операцию (создание, обновление или перемещение) через Git Tree API.
        6.  Создает Pull Request **от имени пользователя**.
    *   **Успешный ответ (`201 Created`):** `{ "message": "...", "pullRequestUrl": "..." }`.

*   **`GET /api/get-prompts` (Публичный)**
    *   **Назначение:** Прокси-эндпоинт для безопасной и кешированной загрузки всех промптов.
    *   **Логика:**
        1.  Используя **серверный, а не пользовательский, токен** (для экономии лимитов пользователей), запрашивает все файлы промптов.
        2.  Запрашивает рейтинги из Vercel KV.
        3.  Обогащает и возвращает объединенные данные.
    *   **Успешный ответ (`200 OK`):** Массив объектов промптов.

##### **3.2. Рейтинги и Комментарии (Vercel Storage)**

*   **`POST /api/vote` (Защищенный)**
    *   **Назначение:** Учет голоса от аутентифицированного пользователя.
    *   **Логика:**
        1.  Проверяет сессию.
        2.  Принимает `promptId` и `direction`.
        3.  (Будущая доработка: проверяет, не голосовал ли этот `userId` за этот `promptId` ранее).
        4.  Атомарно обновляет счетчики в Vercel KV.
    *   **Успешный ответ (`200 OK`):** `{ "upvotes": number, "downvotes": number }`.

*   **`POST /api/comments` (Защищенный)**
    *   **Назначение:** Добавление комментария от аутентифицированного пользователя.
    *   **Логика:**
        1.  Проверяет сессию.
        2.  Принимает `promptId` и `content`.
        3.  **Использует `authorId` и `authorName` из сессии**, а не из тела запроса.
        4.  Создает запись в Vercel Postgres.
    *   **Успешный ответ (`201 Created`):** `{ "message": "Comment added" }`.

*   **`GET /api/comments` (Публичный)**
    *   **Назначение:** Получение списка комментариев.
    *   **Логика:** Выбирает комментарии по `promptId` с пагинацией (`limit`, `offset`).
    *   **Успешный ответ (`200 OK`):** Массив объектов комментариев.

##### **3.3. Авторизация (NextAuth.js)**

*   **`GET /api/auth/[...nextauth]`**
    *   **Назначение:** Набор эндпоинтов, автоматически создаваемых NextAuth.js для управления полным циклом OAuth.
    *   **Ключевые эндпоинты:** `/signin`, `/signout`, `/callback`, `/session`.
    *   **Конфигурация:**
        *   Провайдер: GitHub.
        *   Запрашиваемые права (scope): `user:email`, `public_repo`.
        *   Callback'и: настроены для сохранения `accessToken` и `profile` в JWT сессии.

---

#### **4. Структуры Данных**

##### **4.1. Промпт (JSON в Git)**
Структура обогащается полной информацией об авторе.

```json
{
  "id": "UUID",
  "title": "test",
  "version": "1.0.0",
  "status": "active",
  "is_local": false,
  "is_favorite": false,
  "description": "",
  "content": {
    "ru": "",
    "en": ""
  },
  "prompt_variants": [
    {
      "variant_id": {
        "type": "general",
        "id": "1",
        "priority": 1
      },
      "content": {
        "ru": "",
        "en": ""
      }
    }
  ],
  "compatible_models": ["",""],
  "category": "",
  "tags": [
    "general"
  ],
  "variables": [],
  "metadata": {
    "author": {
      "id": "github-username",
      "name": "GitHub User Name",
      "email": "user@example.com"
    },
    "source": "WebApp",
    "notes": ""
  },
  "rating": {
    "score": 0,
    "votes": 0
  },
  "original_category": ""
}
```

##### **4.2. Комментарий (Схема Prisma)**
```prisma
model Comment {
  id        String   @id @default(cuid())
  promptId  String   // Связь с ID промпта
  content   String
  createdAt DateTime @default(now())
  
  // Связь с пользователем
  authorId  String   // ID пользователя из системы аутентификации
  authorName String  // Имя пользователя на момент комментария
  
  @@index([promptId])
}
```

##### **4.3. Рейтинг (Vercel KV)**
*   **Ключ:** `rating:<promptId>` (остается без изменений)
*   **Ключ для учета голосов (новый):** `votes:<promptId>`, тип `Set`. Хранит `userId`, которые проголосовали.

##### **4.4. Новость (Схема Prisma)**
*   Остается без изменений.

---

#### **5. Нефункциональные Требования**

*   **Безопасность:**
    *   Все секреты (`GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`, `NEXTAUTH_SECRET`, `POSTGRES_URL` и т.д.) должны храниться **только** в переменных окружения Vercel.
    *   Сессионные cookies должны быть защищены флагами `HttpOnly`, `Secure` и `SameSite=Lax`.
    *   OAuth scope должен быть ограничен минимально необходимыми правами (`user:email`, `public_repo`).
    *   Токены пользователей должны храниться только в зашифрованных сессионных JWT, никогда в `localStorage`.
*   **Производительность:** Эндпоинт `GET /api/get-prompts` должен агрессивно кешироваться (`Cache-Control: s-maxage=...`).

---

#### **6. План Разработки**

1.  **Реализация Авторизации (Приоритет 1):**
    *   Создать GitHub OAuth App и настроить `CLIENT_ID` / `CLIENT_SECRET`.
    *   Интегрировать `NextAuth.js` в проект, настроить провайдер GitHub.
    *   Реализовать защиту эндпоинтов, требующих сессии.
    *   Обновить фронтенд для отображения статуса логина и кнопок "Войти/Выйти".
2.  **Обновление логики `create-prompt-issue`:**
    *   Переписать эндпоинт для использования токена пользователя из сессии и добавления данных об авторе.
3.  **Интеграция Vercel Storage (Приоритет 2):**
    *   Подключить Postgres и KV, настроить переменные.
    *   Настроить Prisma, создать миграции для `Comment` и `News`.
4.  **Реализация Рейтингов и Комментариев:**
    *   Создать соответствующие API эндпоинты.

---

#### **7. Альтернативный Вариант Архитектуры (Git-Синхронизированная База Данных)**

**7.1. Концепция**  
В качестве альтернативного подхода рассматривается модель, где:
- Основное хранилище промптов - Vercel Postgres
- Git-репозиторий синхронизируется через GitHub Actions
- Сохраняются преимущества версионирования и PR-процессов

**7.2. Преимущества**
- 🚀 **Гибкие запросы**: Полноценные SQL-запросы к базе данных
- 📉 **Снижение нагрузки**: Меньше запросов к GitHub API
- 💻 **Удобство управления**: Прямое редактирование через административный интерфейс

**7.3. Механизм реализации**
1. **Хранение в Postgres**:
   - Создание таблицы `Prompts` с полями, соответствующими JSON-схеме
   - Интеграция с Prisma ORM

2. **Обновление API**:
   ```javascript
   // Пример изменения эндпоинта
   app.post('/api/create-prompt-issue', async (req, res) => {
     // Запись напрямую в Postgres
     await prisma.prompt.create({ data: req.body });
   });
   ```

3. **GitHub Workflow для синхронизации**:
   - Ежечасная синхронизация данных
   - Автоматическое создание коммитов и PR
   ```yaml
   name: Sync DB to Git
   on:
     schedule:
       - cron: '0 * * * *'
   jobs:
     sync:
       runs-on: ubuntu-latest
       steps:
         - name: Sync prompts
           run: node scripts/sync-prompts.js
   ```

**7.4. Потенциальные сложности**
- Требуется разработка механизма обработки конфликтов
- Необходим переходный период для миграции данных
- Увеличение сложности инфраструктуры
    *   Интегрировать на фронтенде.

---

#### **8. Дополнительные Идеи по Улучшению Проекта**

Эти идеи могут быть реализованы поэтапно, исходя из приоритетов развития проекта и доступных ресурсов.

##### **8.1. Улучшение Пользовательского Опыта и Функциональности (Frontend & API)**

*   **Расширенный Поиск и Фильтрация Промптов:**
    *   Реализовать более сложные поисковые запросы (по автору, по диапазону дат, по совместимым моделям, по количеству голосов).
    *   Добавить возможность комбинировать теги и категории в фильтрах (например, "только промпты для GPT-4 с тегом 'креатив'").
    *   Использование полнотекстового поиска (например, через Vercel Postgres или специализированные решения).
*   **Персонализация и Избранное:**
    *   Развитие функционала "Избранное" для аутентифицированных пользователей, позволяющее сохранять промпты для быстрого доступа.
    *   Рекомендательная система промптов на основе активности пользователя (просмотры, голоса, избранное).
*   **Уведомления Пользователей:**
    *   Уведомления о новых комментариях к своим промптам.
    *   Уведомления о статусе Pull Request (если он был создан пользователем).
    *   Уведомления о новых версиях промптов, которые пользователь добавил в избранное.
*   **Интерактивный "Промпт-Конструктор" / Песочница:**
    *   Интерфейс, позволяющий пользователям тестировать промпты прямо на платформе с выбранными моделями AI (требует интеграции с API AI-моделей).
    *   Возможность сохранения результатов тестирования.
*   **Редактирование комментариев и удаление голосов:** Реализовать функционал для пользователей по редактированию собственных комментариев и отмене ранее сделанных голосов (с соответствующей логикой в Vercel KV).

##### **8.2. Масштабируемость и Производительность**

*   **Оптимизация `GET /api/get-prompts`:**
    *   Если переходить на БД-хранение промптов: глубокая оптимизация запросов к Postgres, индексы, возможно, материализованные представления для часто запрашиваемых данных.
    *   Проработка стратегии инвалидации кеша на Vercel (например, при каждом изменении промпта в Git или БД).
*   **Распределенное кеширование:** Для критически важных или часто запрашиваемых данных рассмотреть использование CDN (Content Delivery Network) перед Vercel для глобального кеширования.
*   **Микросервисная декомпозиция (дальнейшая):** По мере роста проекта, можно рассмотреть выделение отдельных функций (например, сервис комментариев, сервис рейтингов, сервис синхронизации Git) в независимые микросервисы для лучшей масштабируемости и изоляции отказов.

##### **8.3. Улучшение Сопровождаемости и Разработки**

*   **Автоматизированные Тесты:**
    *   Написание unit-тестов для логики валидации, обработки Git-операций, взаимодействия с KV/Postgres.
    *   Интеграционные тесты для API-эндпоинтов, проверяющие полный флоу (аутентификация, создание промпта, голосование).
*   **CI/CD Пайплайн:**
    *   Настройка полноценного CI/CD пайплайна (GitHub Actions) для автоматического запуска тестов, линтинга, сборки и деплоя при каждом изменении кода.
*   **Улучшенное Логирование и Мониторинг:**
    *   Интеграция с централизованной системой логирования (например, Datadog, Sentry, Logtail) для сбора и анализа логов со всех сервисов.
    *   Настройка метрик производительности и алертов для ключевых API-эндпоинтов и хранилищ данных.
*   **OpenAPI/Swagger Документация:** Автоматическая генерация или ручное ведение интерактивной документации API для упрощения работы фронтенда и сторонних разработчиков.

##### **8.4. Безопасность**

*   **Rate Limiting API:** Внедрение механизмов ограничения частоты запросов (rate limiting) для публичных и защищенных эндпоинтов для предотвращения злоупотреблений и DDoS-атак.
*   **Content Security Policy (CSP):** Настройка строгой CSP для фронтенда для защиты от XSS-атак.
*   **Аудит безопасности:** Регулярное проведение аудита безопасности кода и зависимостей, использование инструментов статического анализа кода.
*   **Подтверждение email для GitHub OAuth:** Если `user:email` не всегда возвращает верифицированный email, рассмотреть дополнительное подтверждение email через OTP или другие методы.

##### **8.5. Развитие Сообщества и Модерация**

*   **Модерация Контента:**
    *   Интерфейс для модераторов для ревью и управления промптами, комментариями, новостями.
    *   Система жалоб/репортов на некорректный контент.
*   **Система Репутаций/Уровней Пользователей:**
    *   Накопление "репутации" для пользователей на основе их вклада (количество принятых промптов, полезных комментариев).
    *   Предоставление дополнительных прав или значков для пользователей с высокой репутацией.
*   **Форум / Дискуссии:** Интеграция или создание функционала для обсуждения промптов или общих тем.