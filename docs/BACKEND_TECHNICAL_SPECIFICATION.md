### **Техническое Задание: Бэкенд для проекта "AIPrompts Hub" (Версия 2.0)**

**Версия:** 2.0
**Дата:** 04.08.2025
**Автор:** AI-Аналитик (на основе утвержденной архитектуры)

---

#### **1. Введение**

**1.1. Цель документа**

Настоящее ТЗ описывает требования к архитектуре и API бэкенд-сервиса "AIPrompts Hub", развернутого на платформе Vercel. Документ охватывает как существующую Git-based систему управления контентом (промптами), так и новую гибридную подсистему для управления динамическими данными (рейтинги, комментарии) с использованием нативных хранилищ Vercel.

**1.2. Контекст и Архитектура**

Проект эволюционировал от простого API-шлюза до **гибридной системы**:
*   **Источник правды для контента (Промпты):** Репозиторий GitHub `arnyigor/aiprompts`. Операции записи (создание/обновление) инициируют открытие Pull Request'ов для модерации.
*   **Источник правды для динамических данных (Рейтинги, Комментарии):** Нативные Serverless-хранилища Vercel. Операции записи являются быстрыми и атомарными.

Эта архитектура позволяет использовать сильные стороны каждого подхода: надежность и версионирование Git для контента и производительность баз данных для пользовательского взаимодействия.

---

#### **2. Технологический Стек и Окружение**

*   **Платформа:** Vercel
*   **Среда выполнения:** Node.js
*   **Хранилища данных:**
    *   **Vercel KV (Redis):** Для хранения простых счетчиков (рейтинги).
    *   **Vercel Postgres:** Для хранения структурированных данных (комментарии, новости).
*   **Ключевые зависимости (NPM):**
    *   `@octokit/rest`: Взаимодействие с GitHub REST API.
    *   `zod`: Валидация схем данных.
    *   `@vercel/kv`: Взаимодействие с Vercel KV.
    *   `@vercel/postgres`: Взаимодействие с Vercel Postgres.
*   **Аутентификация:** Использование Personal Access Token (PAT) GitHub и ключей доступа к хранилищам Vercel, хранящихся в переменных окружения.

---

#### **3. Функциональные Требования: API Эндпоинты**

##### **3.1. Управление Промптами (Git-based)**

*   **`POST /api/create-prompt-issue`**
    *   **Назначение:** Принимает данные нового или обновленного промпта.
    *   **Логика:**
        1.  Валидирует данные по схеме Zod.
        2.  Определяет, является ли операция созданием, обновлением или "перемещением" (при смене категории).
        3.  Управляет датами `created_at` / `updated_at` на сервере.
        4.  Создает новую ветку в репозитории `arnyigor/aiprompts`.
        5.  Выполняет атомарную Git-операцию (создание, обновление или удаление+создание) с помощью Git Tree API.
        6.  Создает Pull Request с информативным Markdown-описанием для модерации.
    *   **Структура запроса:** Полный объект промпта (без дат).
    *   **Успешный ответ (`201 Created`):** `{ "message": "...", "pullRequestUrl": "..." }`.

*   **`GET /api/get-prompts`**
    *   **Назначение:** Прокси-эндпоинт для безопасной загрузки всех промптов.
    *   **Логика:**
        1.  Используя серверный токен, запрашивает все файлы промптов из репозитория GitHub.
        2.  **(Интеграция)** Запрашивает рейтинги для всех полученных промптов из Vercel KV.
        3.  Обогащает каждый объект промпта данными о рейтинге.
        4.  Возвращает единый массив обогащенных данных.
    *   **Успешный ответ (`200 OK`):** Массив объектов промптов, каждый с полем `rating: { upvotes: number, downvotes: number }`.

##### **3.2. Рейтинги и Комментарии (Vercel Storage)**

*   **`POST /api/vote`**
    *   **Назначение:** Учет голоса за промпт.
    *   **Логика:**
        1.  Принимает `promptId` и `direction` ('up' или 'down').
        2.  Использует `kv.hincrby` для атомарного увеличения счетчика `upvotes` или `downvotes` для ключа `rating:<promptId>`.
    *   **Успешный ответ (`200 OK`):** `{ "upvotes": number, "downvotes": number }`.

*   **`POST /api/comments`**
    *   **Назначение:** Добавление нового комментария.
    *   **Логика:**
        1.  Принимает `promptId`, `authorName`, `content`.
        2.  Создает новую запись в таблице `Comment` в Vercel Postgres.
    *   **Успешный ответ (`201 Created`):** `{ "message": "Comment added" }`.

*   **`GET /api/comments?promptId=<id>`**
    *   **Назначение:** Получение списка комментариев для конкретного промпта.
    *   **Логика:** Выбирает все комментарии из таблицы `Comment`, где `promptId` совпадает, и сортирует их по дате.
    *   **Успешный ответ (`200 OK`):** Массив объектов комментариев.

##### **3.3. Новости (Будущая реализация)**

*   **`GET /api/news`**
    *   **Назначение:** Получение списка новостей.
    *   **Логика:** Выбирает все записи из таблицы `News` в Vercel Postgres, сортирует по дате публикации.
    *   **Успешный ответ (`200 OK`):** Массив объектов новостей.
*   **`POST /api/news` (Защищенный)**
    *   **Назначение:** Добавление новой новости (требует аутентификации администратора).

---

#### **4. Структуры Данных**

##### **4.1. Промпт (JSON в Git)**
Структура соответствует финальной версии из `constructor.js`.

##### **4.2. Комментарий (Схема Prisma для Vercel Postgres)**
```prisma
model Comment {
  id         String   @id @default(cuid())
  promptId   String   // Связь с ID промпта из JSON
  authorName String
  content    String
  createdAt  DateTime @default(now())

  @@index([promptId])
}
```

##### **4.3. Рейтинг (Структура Hash в Vercel KV)**
*   **Ключ:** `rating:<promptId>`
*   **Поля:**
    *   `upvotes`: number
    *   `downvotes`: number

##### **4.4. Новость (Схема Prisma для Vercel Postgres)**
```prisma
model News {
  id          String   @id @default(cuid())
  title       String
  content     String   // Содержимое в формате Markdown
  imageUrl    String?
  publishedAt DateTime @default(now())
  authorName  String
}
```

---

#### **5. Нефункциональные Требования**

*   **Безопасность:** Все секретные ключи (`GITHUB_TOKEN`, `POSTGRES_URL`, `KV_REST_API_URL` и т.д.) должны храниться **только** в переменных окружения Vercel.
*   **Производительность:** Эндпоинт `GET /api/get-prompts` должен использовать кеширование Vercel (`Cache-Control: s-maxage=...`) для минимизации запросов к GitHub API.
*   **Масштабируемость:** Использование Serverless-функций и нативных хранилищ Vercel обеспечивает автоматическое масштабирование под нагрузкой.

---

#### **6. План Миграции и Разработки**

1.  **Интеграция Vercel Storage:** Подключить Postgres и KV в дашборде Vercel, настроить переменные окружения.
2.  **Установка зависимостей:** Добавить `@vercel/postgres`, `@vercel/kv`.
3.  **Реализация Рейтингов:**
    *   Создать эндпоинт `POST /api/vote`.
    *   Модифицировать `GET /api/get-prompts` для обогащения данных.
    *   Интегрировать на фронтенде.
4.  **Реализация Комментариев:**
    *   Настроить Prisma и создать миграцию для таблицы `Comment`.
    *   Создать эндпоинты `POST /api/comments` и `GET /api/comments`.
    *   Интегрировать на фронтенде.
5.  **Реализация Новостей (будущий этап):**
    *   Создать миграцию Prisma для таблицы `News`.
    *   Создать эндпоинты `GET /api/news` и (позже) защищенный `POST /api/news`.
    *   Создать новый раздел в UI.