Конечно. Вы предоставили очень подробный и дальновидный план. Интеграция полноценной OAuth-аутентификации — это следующий, самый важный шаг в развитии вашего проекта. Он превращает его из анонимного инструмента в платформу для контрибьюторов.

Я возьму ваше текущее ТЗ и полностью переработаю его, чтобы оно отражало эту новую, более зрелую и безопасную архитектуру.

### АКТВИРОВАН ПРОФІЛЬ 2: Исследователь-аналитик

---

### **Техническое Задание: AIPrompts Hub — Архитектура v3.0**

**Версия:** 3.0
**Дата:** 05.08.2025
**Автор:** AI-Аналитик (на основе утвержденной архитектуры)

---

#### **1. Введение**

**1.1. Цель документа**

Настоящее ТЗ описывает требования к внедрению **системы аутентификации пользователей через GitHub OAuth** и расширению гибридной архитектуры бэкенд-сервиса "AIPrompts Hub". Документ детализирует новые API-маршруты для авторизации, обновляет требования к существующим эндпоинтам и определяет новые стандарты безопасности.

**1.2. Контекст и Архитектура**

Проект переходит на **идентификационную модель участия**. Все операции, изменяющие контент (создание/редактирование промптов), теперь будут выполняться от имени аутентифицированного пользователя, что повышает прозрачность и безопасность.

Архитектура остается **гибридной**, но обогащается новым слоем:
*   **Слой Аутентификации (NextAuth.js):** Централизованно управляет сессиями пользователей и доступом к защищенным API.
*   **Источник правды для контента (Git):** Остается без изменений, но операции теперь используют персональные токены пользователей.
*   **Источник правды для динамических данных (Vercel Storage):** Остается без изменений.

---

#### **2. Технологический Стек и Окружение**

*   **Платформа:** Vercel
*   **Среда выполнения:** Node.js
*   **Хранилища данных:**
    *   Vercel KV (Redis)
    *   Vercel Postgres
*   **Ключевые зависимости (NPM):**
    *   `@octokit/rest`: Взаимодействие с GitHub REST API.
    *   `zod`: Валидация схем данных.
    *   `@vercel/kv`, `@vercel/postgres`: Работа с хранилищами.
    *   **`next-auth`**: Ключевая библиотека для реализации GitHub OAuth.
*   **Аутентификация:** GitHub OAuth flow, управляемый `NextAuth.js`. **Персональные токены пользователей**, полученные через OAuth, используются для Git-операций вместо единого серверного PAT.

---

#### **3. Функциональные Требования: API Эндпоинты**

##### **3.1. Управление Промптами (Git-based)**

*   **`POST /api/create-prompt-issue` (Защищенный)**
    *   **Назначение:** Принимает данные нового или обновленного промпта от **аутентифицированного пользователя**.
    *   **Логика:**
        1.  Проверяет наличие активной сессии пользователя.
        2.  Валидирует данные по схеме Zod.
        3.  Управляет датами `created_at` / `updated_at` на сервере.
        4.  **Автоматически обогащает** данные информацией об авторе из сессии (GitHub username, id, email).
        5.  Используя **токен пользователя из сессии**, выполняет атомарную Git-операцию (создание, обновление или перемещение) через Git Tree API.
        6.  Создает Pull Request **от имени пользователя**.
    *   **Успешный ответ (`201 Created`):** `{ "message": "...", "pullRequestUrl": "..." }`.

*   **`GET /api/get-prompts` (Публичный)**
    *   **Назначение:** Прокси-эндпоинт для безопасной и кешированной загрузки всех промптов.
    *   **Логика:**
        1.  Используя **серверный, а не пользовательский, токен** (для экономии лимитов пользователей), запрашивает все файлы промптов.
        2.  Запрашивает рейтинги из Vercel KV.
        3.  Обогащает и возвращает объединенные данные.
    *   **Успешный ответ (`200 OK`):** Массив объектов промптов.

##### **3.2. Рейтинги и Комментарии (Vercel Storage)**

*   **`POST /api/vote` (Защищенный)**
    *   **Назначение:** Учет голоса от аутентифицированного пользователя.
    *   **Логика:**
        1.  Проверяет сессию.
        2.  Принимает `promptId` и `direction`.
        3.  (Будущая доработка: проверяет, не голосовал ли этот `userId` за этот `promptId` ранее).
        4.  Атомарно обновляет счетчики в Vercel KV.
    *   **Успешный ответ (`200 OK`):** `{ "upvotes": number, "downvotes": number }`.

*   **`POST /api/comments` (Защищенный)**
    *   **Назначение:** Добавление комментария от аутентифицированного пользователя.
    *   **Логика:**
        1.  Проверяет сессию.
        2.  Принимает `promptId` и `content`.
        3.  **Использует `authorId` и `authorName` из сессии**, а не из тела запроса.
        4.  Создает запись в Vercel Postgres.
    *   **Успешный ответ (`201 Created`):** `{ "message": "Comment added" }`.

*   **`GET /api/comments` (Публичный)**
    *   **Назначение:** Получение списка комментариев.
    *   **Логика:** Выбирает комментарии по `promptId` с пагинацией (`limit`, `offset`).
    *   **Успешный ответ (`200 OK`):** Массив объектов комментариев.

##### **3.3. Авторизация (NextAuth.js)**

*   **`GET /api/auth/[...nextauth]`**
    *   **Назначение:** Набор эндпоинтов, автоматически создаваемых NextAuth.js для управления полным циклом OAuth.
    *   **Ключевые эндпоинты:** `/signin`, `/signout`, `/callback`, `/session`.
    *   **Конфигурация:**
        *   Провайдер: GitHub.
        *   Запрашиваемые права (scope): `user:email`, `public_repo`.
        *   Callback'и: настроены для сохранения `accessToken` и `profile` в JWT сессии.

---

#### **4. Структуры Данных**

##### **4.1. Промпт (JSON в Git)**
Структура обогащается полной информацией об авторе.

```json
{
  "id": "UUID",
  "title": "test",
  "version": "1.0.0",
  "status": "active",
  "is_local": false,
  "is_favorite": false,
  "description": "",
  "content": {
    "ru": "",
    "en": ""
  },
  "prompt_variants": [
    {
      "variant_id": {
        "type": "general",
        "id": "1",
        "priority": 1
      },
      "content": {
        "ru": "",
        "en": ""
      }
    }
  ],
  "compatible_models": ["",""],
  "category": "",
  "tags": [
    "general"
  ],
  "variables": [],
  "metadata": {
    "author": {
      "id": "github-username",
      "name": "GitHub User Name",
      "email": "user@example.com"
    },
    "source": "WebApp",
    "notes": ""
  },
  "rating": {
    "score": 0,
    "votes": 0
  },
  "original_category": ""
}
```

##### **4.2. Комментарий (Схема Prisma)**
```prisma
model Comment {
  id        String   @id @default(cuid())
  promptId  String   // Связь с ID промпта
  content   String
  createdAt DateTime @default(now())
  
  // Связь с пользователем
  authorId  String   // ID пользователя из системы аутентификации
  authorName String  // Имя пользователя на момент комментария
  
  @@index([promptId])
}
```

##### **4.3. Рейтинг (Vercel KV)**
*   **Ключ:** `rating:<promptId>` (остается без изменений)
*   **Ключ для учета голосов (новый):** `votes:<promptId>`, тип `Set`. Хранит `userId`, которые проголосовали.

##### **4.4. Новость (Схема Prisma)**
*   Остается без изменений.

---

#### **5. Нефункциональные Требования**

*   **Безопасность:**
    *   Все секреты (`GITHUB_OAUTH_CLIENT_ID`, `GITHUB_OAUTH_CLIENT_SECRET`, `NEXTAUTH_SECRET`, `POSTGRES_URL` и т.д.) должны храниться **только** в переменных окружения Vercel.
    *   Сессионные cookies должны быть защищены флагами `HttpOnly`, `Secure` и `SameSite=Lax`.
    *   OAuth scope должен быть ограничен минимально необходимыми правами (`user:email`, `public_repo`).
    *   Токены пользователей должны храниться только в зашифрованных сессионных JWT, никогда в `localStorage`.
*   **Производительность:** Эндпоинт `GET /api/get-prompts` должен агрессивно кешироваться (`Cache-Control: s-maxage=...`).

---

#### **6. План Разработки**

1.  **Реализация Авторизации (Приоритет 1):**
    *   Создать GitHub OAuth App и настроить `CLIENT_ID` / `CLIENT_SECRET`.
    *   Интегрировать `NextAuth.js` в проект, настроить провайдер GitHub.
    *   Реализовать защиту эндпоинтов, требующих сессии.
    *   Обновить фронтенд для отображения статуса логина и кнопок "Войти/Выйти".
2.  **Обновление логики `create-prompt-issue`:**
    *   Переписать эндпоинт для использования токена пользователя из сессии и добавления данных об авторе.
3.  **Интеграция Vercel Storage (Приоритет 2):**
    *   Подключить Postgres и KV, настроить переменные.
    *   Настроить Prisma, создать миграции для `Comment` и `News`.
4.  **Реализация Рейтингов и Комментариев:**
    *   Создать соответствующие API эндпоинты.
    *   Интегрировать на фронтенде.